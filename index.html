<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カオスゼロナイトメア セーブデータ容量計算ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 - Deep Dark Blue */
        }
        .card-shadow {
            box-shadow: 0 0 10px rgba(79, 70, 229, 0.5); /* Indigo glow */
            border: 1px solid #4f46e5;
        }
        .tab-active {
            background-color: #4f46e5; /* Indigo 600 */
            color: #ffffff;
            box-shadow: 0 0 8px rgba(129, 140, 248, 0.7); /* Light indigo glow */
        }
        .tab-inactive {
            background-color: #1f2937; /* Gray 800 */
            color: #9ca3af; /* Gray 400 */
            border: 1px solid #374151;
        }
        input[type="number"] {
            -moz-appearance: textfield; /* Firefox */
        }
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .input-bg {
            background-color: #1e293b; /* Slate 800 */
            border: 1px solid #334155; /* Slate 700 */
            color: #e2e8f0; /* Slate 200 */
        }
        /* New styles for button controls */
        .control-btn {
            width: 2.5rem; /* 40px */
            height: 2.5rem; /* 40px */
            border-radius: 0.5rem; /* rounded */
            font-size: 1.25rem;
            line-height: 1;
            font-weight: 700;
            transition: all 0.2s;
        }
        .control-btn:hover {
            transform: scale(1.05);
        }
        .btn-minus {
            background-color: #ef4444; /* Red 500 */
            box-shadow: 0 0 5px rgba(239, 68, 68, 0.5);
        }
        .btn-plus {
            background-color: #10b981; /* Green 500 */
            box-shadow: 0 0 5px rgba(16, 185, 129, 0.5);
        }
        .count-display {
            min-width: 3rem; 
            text-align: center;
            font-size: 1.125rem;
            padding: 0.25rem 0.25rem;
            background-color: #0f172a; 
            border: 1px solid #334155;
            box-shadow: 0 0 5px rgba(51, 65, 85, 0.5); 
        }

        /* 入力行のレイアウト */
        .input-row-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background-color: #1f2937; /* Gray 800 */
            border-radius: 0.75rem;
            border: 1px solid #374151;
            flex-direction: column;
            align-items: flex-start;
        }
        .note-text {
            /* flex-col内に<br>が入ったため、HTMLレンダリングを有効にする */
            line-height: 1.4;
        }
        .cost-detail {
            font-size: 0.75rem; /* text-xs */
            font-weight: 600; /* font-semibold */
            color: #94a3b8; /* Slate 400 */
            margin-left: 0.5rem;
            display: block; /* 常に横並びを意識 */
        }
    </style>
</head>
<body class="p-4 sm:p-8 min-h-screen">

    <div id="app" class="max-w-5xl mx-auto">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-white mb-8 text-center tracking-wider">
            カオスゼロナイトメア セーブデータ容量計算
        </h1>

        <!-- 1. 基本情報と最大容量 (修正1: 上下段レイアウトに戻す) -->
        <div class="bg-gray-900 p-6 sm:p-8 rounded-xl card-shadow mb-8">
            <h2 class="text-2xl font-bold text-indigo-400 mb-4 border-b border-indigo-700 pb-2 text-center">セーブデータ基本設定</h2>
            
            <div class="space-y-6"> 
                
                <!-- ティア設定 -->
                <div>
                    <label for="tier" class="block text-sm font-medium text-gray-300 mb-2">カオス ティア</label>
                    <input type="number" id="tier" value="1" min="1" oninput="updateTier(this)"
                        class="w-full p-3 input-bg rounded-lg text-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>

                <!-- セーブデータ容量結果表示 -->
                <div class="p-5 bg-indigo-900/40 rounded-lg border border-indigo-700 flex flex-col justify-center">
                    <p class="text-sm font-semibold text-gray-300 mb-2">最大セーブデータ容量</p>
                    <p class="text-xl font-extrabold text-white">
                        <span class="text-yellow-300 text-3xl mr-1" id="max-pt">30</span> Pt
                    </p>
                    <p class="text-xs text-gray-400 mt-1">※ 30pt + (Tier - 1) x 10pt</p>
                </div>
            </div>
        </div>

        <!-- 2. 消費コスト入力（左右分割） -->
        <div class="bg-gray-900 p-6 sm:p-8 rounded-xl card-shadow mb-8">
            <h2 class="text-2xl font-bold text-cyan-400 mb-4 border-b border-cyan-700 pb-2 text-center">所持カードとカオス内アクション</h2>

            <div class="flex justify-center space-x-2 mb-6">
                <button class="px-3 sm:px-6 py-2 rounded-full font-bold transition duration-200 tab-active"
                    id="tab-A" onclick="switchTab('A')" data-char="A">キャラクター A</button>
                <button class="px-3 sm:px-6 py-2 rounded-full font-bold transition duration-200 tab-inactive"
                    id="tab-B" onclick="switchTab('B')" data-char="B">キャラクター B</button>
                <button class="px-3 sm:px-6 py-2 rounded-full font-bold transition duration-200 tab-inactive"
                    id="tab-C" onclick="switchTab('C')" data-char="C">キャラクター C</button>
            </div>
            
            <!-- 修正2: キャラクター名入力欄をタブの下に移動し、挙動を調整 -->
            <div id="char-name-container" class="mb-8 px-4">
                <label for="char-name" class="block text-sm font-medium text-gray-300 mb-2">選択中キャラクター名</label>
                <input type="text" id="char-name" value="" placeholder="キャラクター A" oninput="updateName(this)"
                    class="w-full p-3 input-bg rounded-lg text-lg focus:ring-indigo-500 focus:border-indigo-500" maxlength="15">
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- 左：所持カード -->
                <div>
                    <h3 class="text-xl font-semibold text-gray-200 mb-4 text-center py-2 bg-slate-800 rounded-lg border-b border-cyan-500/50">所持カード</h3>
                    <div id="card-inputs" class="space-y-4">
                        <!-- Inputs generated by JS with buttons -->
                    </div>
                    <p class="text-xs text-gray-500 mt-4 px-2">※固有カード・装備は鮮明な記憶としてコスト0ptです。</p>
                </div>

                <!-- 右：カオス内アクション -->
                <div>
                    <h3 class="text-xl font-semibold text-gray-200 mb-4 text-center py-2 bg-slate-800 rounded-lg border-b border-cyan-500/50">カオス内アクション</h3>
                    <div id="action-inputs" class="space-y-4">
                        <!-- Inputs generated by JS with buttons -->
                    </div>
                </div>
            </div>

                <!-- 合計コスト表示 -->
                <div class="mt-8 p-4 bg-cyan-900/40 rounded-lg border border-cyan-700 text-center">
                    <p class="text-lg font-semibold text-gray-300">
                        純粋な追加コスト:
                        <span id="total-cost-final" class="text-red-400 font-bold text-3xl ml-2">0</span> Pt
                        <span class="text-lg text-gray-400">／</span>
                        <span id="max-pt-final" class="text-cyan-400 font-bold text-2xl">30</span> pt (最大容量)
                    </p>
                </div>
        </div>

        <!-- 3. 最終結果 (修正3: タイトル変更) -->
        <div class="p-6 sm:p-8 rounded-xl border border-gray-700 bg-gray-900/50">
            <h2 class="text-2xl font-bold text-red-400 mb-6 text-center border-b border-red-700 pb-2">キャラクター別セーブデータ使用量</h2>
            
            <div id="final-summary" class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <!-- 結果はJSで動的に生成 -->
            </div>
        </div>
    </div>

<script>
    // コスト定数
    const COSTS = [
        { id: 'common_card', label: '共用カード', cost: 20, type: 'card', note: '※ 単価: +20pt' },
        { id: 'monster_card', label: 'モンスターカード', cost: 80, type: 'card', note: '※ 単価: +80pt' }, 
        { id: 'normal_hirameki', label: '通常ヒラメキ', cost: 10, type: 'card', 
          note: '※ 単価: +10pt <br>※ 共用・モンスターカードが対象 <br>※ 開始・ヒラメキカードは0pt' }, 
        { id: 'god_hirameki', cost: 20, type: 'card', 
          note: '※ 単価: +20pt <br>※ 開始・ヒラメキカード含めた全カード対象' }, 

        { id: 'convert_card', label: 'カード変換回数', cost: 10, type: 'action', 
          note: '※ 単価: +10pt' }, 
          
        { id: 'copy_card', label: 'カードコピー回数', cost: 0, type: 'action', // コストはロジックで計算
          note: '※ 回数に応じて: 0pt, 10pt, 30pt, 50pt, 70pt (以降70pt固定) <br>※ コピーで増加したカードのポイントは別途加算してください。' }, 
          
        { id: 'exclude_cumulative', label: 'カード排除回数 (累積コスト)', cost: 0, type: 'action', 
          note: '※ 累積コスト（0pt, +10pt, +40pt...）を計算します。 <br>※ 開始・ヒラメキカードを排除する場合は合わせて⇩の開始・ヒラメキカード排除回数をカウントしてください。' }, 
          
        { id: 'exclude_start_hirameki_fixed', label: '開始・ヒラメキカード排除回数 (固定コスト)', cost: 20, type: 'action', 
          note: '※ この回数分、一律 +20pt が加算されます。' } 
    ];

    // 状態管理（キャラクターA, B, Cのデータ）
    let calculatorState = {
        activeCharacter: 'A',
        // ★★★ 修正1: ティアをグローバル状態として分離 ★★★
        tier: 1, 
        A: { name: 'キャラクター A', costs: {} }, // .tier プロパティを削除
        B: { name: 'キャラクター B', costs: {} }, // .tier プロパティを削除
        C: { name: 'キャラクター C', costs: {} }  // .tier プロパティを削除
    };

    // 初期化処理
    document.addEventListener('DOMContentLoaded', () => {
        initializeState();
        initializeInputGroups();
        // 初期ロード時にティアの計算と反映も行う
        updateTier(document.getElementById('tier')); 
        calculatePt(); 
        
        document.getElementById('char-name').value = "";
        document.getElementById('char-name').placeholder = calculatorState.A.name;
    });

    // 状態オブジェクトの初期化
    function initializeState() {
        ['A', 'B', 'C'].forEach(char => {
            COSTS.forEach(item => {
                calculatorState[char].costs[item.id] = 0;
            });
        });
    }

    // 入力グループの動的生成 (省略)
    function initializeInputGroups() {
        const cardContainer = document.getElementById('card-inputs');
        const actionContainer = document.getElementById('action-inputs');
        
        cardContainer.innerHTML = '';
        actionContainer.innerHTML = '';

        COSTS.forEach(item => {
            const container = item.type === 'card' ? cardContainer : actionContainer;
            
            const div = document.createElement('div');
            div.className = 'input-row-card'; 
            
            div.innerHTML = `
                <div class="w-full flex flex-col mb-2">
                    <label class="block text-base font-medium text-gray-300">${item.label}</label>
                    <span class="text-xs font-mono text-gray-500 note-text whitespace-normal">${item.note}</span>
                </div>

                <div class="w-full flex items-center justify-between pt-2 border-t border-gray-700/50">
                    <div class="flex flex-col">
                        <span class="text-xs text-gray-500">消費Pt:</span>
                        <div class="flex items-baseline">
                            <span id="cost-pt-${item.id}" class="text-xl font-bold text-gray-400">+0 Pt</span>
                            <span id="cost-detail-${item.id}" class="cost-detail"></span>
                        </div>
                    </div>
                    
                    <div class="flex items-center space-x-1">
                        <button class="control-btn btn-minus text-white" onclick="adjustCost('${item.id}', -1)">-</button>
                        <span id="display-${item.id}" class="count-display rounded-md text-white font-bold">0</span>
                        <button class="control-btn btn-plus text-white" onclick="adjustCost('${item.id}', 1)">+</button>
                    </div>
                </div>
            `;
            div.querySelector('.note-text').innerHTML = item.note; 
            container.appendChild(div);
        });
    }

    // コスト調整機能 (変更なし)
    function adjustCost(id, delta) {
        const char = calculatorState.activeCharacter;
        let currentValue = calculatorState[char].costs[id];
        
        let newValue = currentValue + delta;
        
        if (newValue < 0) {
            newValue = 0; // Prevent negative counts
        }

        // 1. Update state
        calculatorState[char].costs[id] = newValue;
        
        // 2. Update display
        document.getElementById(`display-${id}`).textContent = newValue;
        
        // 3. Recalculate everything
        calculatePt();
    }

    // キャラクター名更新ロジック (変更なし)
    function updateName(inputElement) {
        const char = calculatorState.activeCharacter;
        const defaultName = `キャラクター ${char}`;
        
        const newName = inputElement.value.trim() || defaultName; 
        calculatorState[char].name = newName;
        
        document.getElementById(`tab-${char}`).textContent = newName;
        
        calculatePt();
    }

    function switchTab(newChar) {
        const activeChar = calculatorState.activeCharacter;
        saveCurrentState(activeChar); // 現在の名前のみを保存 (ティアは含まない)

        document.getElementById(`tab-${activeChar}`).className = document.getElementById(`tab-${activeChar}`).className.replace('tab-active', 'tab-inactive');
        document.getElementById(`tab-${newChar}`).className = document.getElementById(`tab-${newChar}`).className.replace('tab-inactive', 'tab-active');
        calculatorState.activeCharacter = newChar;
        loadState(newChar); // 新しいキャラクターの名前とコストをロード (ティアは含まない)
        calculatePt();
    }

    // ★★★ 修正2: saveCurrentStateからティアの保存ロジックを削除 ★★★
    function saveCurrentState(char) {
        const state = calculatorState[char];
        // ティアはグローバルに分離されたため、ここでは保存しない
        
        const inputName = document.getElementById('char-name').value.trim();
        const defaultName = `キャラクター ${char}`;
        state.name = inputName || defaultName;
    }

    // ★★★ 修正2: loadStateからティアのロードロジックを削除 ★★★
    function loadState(char) {
        const state = calculatorState[char];
        const defaultName = `キャラクター ${char}`;

        // Tierのロード処理を削除
        
        if (state.name === defaultName) {
             document.getElementById('char-name').value = "";
             document.getElementById('char-name').placeholder = defaultName;
        } else {
             document.getElementById('char-name').value = state.name;
             document.getElementById('char-name').placeholder = defaultName;
        }

        document.getElementById(`tab-${char}`).textContent = state.name;

        COSTS.forEach(item => {
            const count = state.costs[item.id];
            const displayElement = document.getElementById(`display-${item.id}`);
            if (displayElement) {
                displayElement.textContent = count;
            }
        });
    }

    // ★★★ 修正3: updateTierでグローバルなティア状態を管理し、全表示を更新 ★★★
    function updateTier(inputElement) { 
        // 1. 入力検証と値の修正
        if (inputElement.value < 1 || inputElement.value === "") { 
            inputElement.value = 1;
        }
        
        const currentTier = parseInt(inputElement.value) || 1;
        const maxPt = 30 + (currentTier - 1) * 10;

        // 2. 【グローバル状態に保存】 ティアの値をグローバルな状態に保存
        calculatorState.tier = currentTier;
        
        // 3. 全ての最大容量の表示を更新
        document.getElementById('max-pt').textContent = maxPt; // 基本設定の最大容量
        document.getElementById('max-pt-final').textContent = maxPt; // 中間合計コストの最大容量
        
        // 4. 全キャラクター別セーブデータ使用量の最大容量表示を更新
        ['A', 'B', 'C'].forEach(charKey => {
            const charMaxPtElement = document.getElementById(`char${charKey}_maxPt`);
            if (charMaxPtElement) {
                charMaxPtElement.textContent = maxPt;
            }
        });

        // 5. 念のため再計算を呼び出し、現在のコスト表示を更新
        calculatePt(); 
    }
    
    // --- コスト計算ロジック (変更なし) ---
    
    function calculateTotalCumulativeCost(count) {
        if (count <= 0) return { totalCost: 0, detail: "" };

        let totalCost = 0;
        let detail = [];
        const diffCosts = [0, 10, 30, 50]; 

        for (let i = 1; i <= count; i++) {
            let diff;
            if (i <= 4) {
                diff = diffCosts[i - 1];
            } else {
                diff = 70;
            }
            totalCost += diff;
            detail.push(diff === 0 ? '+0' : `+${diff}`);
        }
        return { totalCost, detail: `(${detail.join(' ')})` };
    }

    const updateIndividualCostDisplay = (char, id, cost, detail = "") => {
        if (char !== calculatorState.activeCharacter) return;
        
        const costElement = document.getElementById(`cost-pt-${id}`);
        const detailElement = document.getElementById(`cost-detail-${id}`);

        if (costElement) {
            let colorClass = 'text-gray-400';
            if (cost > 0) {
                colorClass = 'text-red-400';
            }

            costElement.textContent = `${cost >= 0 ? '+' : ''}${cost} Pt`;
            costElement.className = `text-xl font-bold ${colorClass}`;
        }

        if (detailElement) {
             detailElement.textContent = detail;
        }
    };

    // ★★★ 修正4: calculateCharacterResultでグローバルなティアを使用 ★★★
    function calculateCharacterResult(char) {
        const state = calculatorState[char];
        // ティアはグローバルな状態から取得
        const tier = calculatorState.tier; 
        
        // 1. 最大容量の計算
        const maxPt = 30 + (tier - 1) * 10; // tierを使用

        let totalCost = 0; // 純粋な追加コスト (使用量)

        // 2. 所持カードコストの計算と表示
        COSTS.filter(item => item.type === 'card').forEach(item => {
            const count = state.costs[item.id];
            const cost = item.cost * count;
            totalCost += cost;
            updateIndividualCostDisplay(char, item.id, cost);
        });
        
        // 3. 特殊アクションコストの計算と表示 (省略)
        const convertCount = state.costs['convert_card'];
        const convertCost = convertCount * 10;
        totalCost += convertCost;
        updateIndividualCostDisplay(char, 'convert_card', convertCost);
        
        const copyCount = state.costs['copy_card'];
        const { totalCost: copyCumulativeCost, detail: copyDetail } = calculateTotalCumulativeCost(copyCount);
        totalCost += copyCumulativeCost;
        updateIndividualCostDisplay(char, 'copy_card', copyCumulativeCost, copyDetail);

        const excludeCumulativeCount = state.costs['exclude_cumulative'];
        const { totalCost: excludeCumulativeCost, detail: excludeDetail } = calculateTotalCumulativeCost(excludeCumulativeCount);
        totalCost += excludeCumulativeCost;
        updateIndividualCostDisplay(char, 'exclude_cumulative', excludeCumulativeCost, excludeDetail);

        const startHiramekiFixedCount = state.costs['exclude_start_hirameki_fixed'];
        const startHiramekiCost_fixed = startHiramekiFixedCount * COSTS.find(item => item.id === 'exclude_start_hirameki_fixed').cost; 
        totalCost += startHiramekiCost_fixed;
        updateIndividualCostDisplay(char, 'exclude_start_hirameki_fixed', startHiramekiCost_fixed);

        // 4. 最終結果
        const exceededPt = Math.max(0, totalCost - maxPt);

        return { maxPt, totalCost, exceededPt, name: state.name };
    }


    // メイン計算ロジック
    function calculatePt() {
        const activeChar = calculatorState.activeCharacter;
        
        // 1. アクティブキャラクターの名前のみを保存
        saveCurrentState(activeChar);

        // 2. アクティブキャラクターの結果を計算し、フォームに反映
        const activeResult = calculateCharacterResult(activeChar);

        // 中間合計コスト表示を更新
        document.getElementById('total-cost-final').textContent = activeResult.totalCost;
        document.getElementById('max-pt-final').textContent = activeResult.maxPt;
        document.getElementById('max-pt').textContent = activeResult.maxPt; // 基本設定の最大容量も更新

        // 3. 全キャラクターの結果を計算し、サマリーに表示
        const summaryContainer = document.getElementById('final-summary');
        summaryContainer.innerHTML = ''; 

        ['A', 'B', 'C'].forEach(char => {
            const result = calculateCharacterResult(char); // グローバルティアを使用
            const charName = result.name || `キャラクター ${char}`;

            let statusHtml = '';
            if (result.exceededPt > 0) {
                statusHtml = `<p class="text-red-400 font-bold mt-2 text-sm">超過: ${result.exceededPt} Pt</p>`;
            }
            
            const charCard = document.createElement('div');
            charCard.className = `p-4 rounded-xl border-2 transition duration-200 ${char === activeChar ? 'border-indigo-400 bg-gray-800' : 'border-gray-700 bg-gray-800/50'}`;
            
            charCard.innerHTML = `
                <p class="text-xl font-bold ${char === activeChar ? 'text-indigo-300' : 'text-gray-300'}">
                    ${charName}
                </p>
                <div class="mt-2">
                    <p class="text-2xl font-extrabold text-white">
                        現在${result.totalCost} <span class="text-lg font-normal">pt</span> <span class="text-base text-gray-400">使用</span>
                    </p>
                    <p class="text-sm text-gray-500 mt-1">
                        (最大容量: <span id="char${char}_maxPt">${result.maxPt}</span> pt)
                    </p>
                    ${statusHtml}
                </div>
            `;
            summaryContainer.appendChild(charCard);
        });
    }
</script>
</body>
</html>
